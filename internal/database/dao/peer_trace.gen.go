// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
        "context"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/schema"

        "gorm.io/gen"
        "gorm.io/gen/field"

        "gorm.io/plugin/dbresolver"
		"github.com/bitmagnet-io/bitmagnet/internal/model"
)

func newPeerTrace(db *gorm.DB, opts ...gen.DOOption) peerTrace {
        _peerTrace := peerTrace{}

        _peerTrace.peerTraceDo.UseDB(db, opts...)
        _peerTrace.peerTraceDo.UseModel(&model.PeerTrace{})

        tableName := _peerTrace.peerTraceDo.TableName()
        _peerTrace.ALL = field.NewAsterisk(tableName)
        _peerTrace.IP = field.NewString(tableName, "ip")
        _peerTrace.InfoHash = field.NewField(tableName, "info_hash")
        _peerTrace.LastSeenTime = field.NewTime(tableName, "last_seen_time")

        _peerTrace.fillFieldMap()

        return _peerTrace
}

type peerTrace struct {
        peerTraceDo peerTraceDo

        ALL          field.Asterisk
        IP           field.String
        InfoHash     field.Field
        LastSeenTime field.Time

        fieldMap map[string]field.Expr
}

func (p peerTrace) Table(newTableName string) *peerTrace {
        p.peerTraceDo.UseTable(newTableName)
        return p.updateTableName(newTableName)
}

func (p peerTrace) As(alias string) *peerTrace {
        p.peerTraceDo.DO = *(p.peerTraceDo.As(alias).(*gen.DO))
        return p.updateTableName(alias)
}

func (p *peerTrace) updateTableName(table string) *peerTrace {
        p.ALL = field.NewAsterisk(table)
        p.IP = field.NewString(table, "ip")
        p.InfoHash = field.NewField(table, "info_hash")
        p.LastSeenTime = field.NewTime(table, "last_seen_time")

        p.fillFieldMap()

        return p
}

func (p *peerTrace) WithContext(ctx context.Context) *peerTraceDo {
        return p.peerTraceDo.WithContext(ctx)
}

func (p peerTrace) TableName() string { return p.peerTraceDo.TableName() }

func (p peerTrace) Alias() string { return p.peerTraceDo.Alias() }

func (p peerTrace) Columns(cols ...field.Expr) gen.Columns { return p.peerTraceDo.Columns(cols...) }

func (p *peerTrace) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
        _f, ok := p.fieldMap[fieldName]
        if !ok || _f == nil {
                return nil, false
        }
        _oe, ok := _f.(field.OrderExpr)
        return _oe, ok
}

func (p *peerTrace) fillFieldMap() {
        p.fieldMap = make(map[string]field.Expr, 3)
        p.fieldMap["ip"] = p.IP
        p.fieldMap["info_hash"] = p.InfoHash
        p.fieldMap["last_seen_time"] = p.LastSeenTime
}

func (p peerTrace) clone(db *gorm.DB) peerTrace {
        p.peerTraceDo.ReplaceConnPool(db.Statement.ConnPool)
        return p
}

func (p peerTrace) replaceDB(db *gorm.DB) peerTrace {
        p.peerTraceDo.ReplaceDB(db)
        return p
}

type peerTraceDo struct{ gen.DO }

func (p peerTraceDo) Debug() *peerTraceDo {
        return p.withDO(p.DO.Debug())
}

func (p peerTraceDo) WithContext(ctx context.Context) *peerTraceDo {
        return p.withDO(p.DO.WithContext(ctx))
}

func (p peerTraceDo) ReadDB() *peerTraceDo {
        return p.Clauses(dbresolver.Read)
}

func (p peerTraceDo) WriteDB() *peerTraceDo {
        return p.Clauses(dbresolver.Write)
}

func (p peerTraceDo) Session(config *gorm.Session) *peerTraceDo {
        return p.withDO(p.DO.Session(config))
}

func (p peerTraceDo) Clauses(conds ...clause.Expression) *peerTraceDo {
        return p.withDO(p.DO.Clauses(conds...))
}

func (p peerTraceDo) Returning(value interface{}, columns ...string) *peerTraceDo {
        return p.withDO(p.DO.Returning(value, columns...))
}

func (p peerTraceDo) Not(conds ...gen.Condition) *peerTraceDo {
        return p.withDO(p.DO.Not(conds...))
}

func (p peerTraceDo) Or(conds ...gen.Condition) *peerTraceDo {
        return p.withDO(p.DO.Or(conds...))
}

func (p peerTraceDo) Select(conds ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.Select(conds...))
}

func (p peerTraceDo) Where(conds ...gen.Condition) *peerTraceDo {
        return p.withDO(p.DO.Where(conds...))
}

func (p peerTraceDo) Order(conds ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.Order(conds...))
}

func (p peerTraceDo) Distinct(cols ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.Distinct(cols...))
}

func (p peerTraceDo) Omit(cols ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.Omit(cols...))
}

func (p peerTraceDo) Join(table schema.Tabler, on ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.Join(table, on...))
}

func (p peerTraceDo) LeftJoin(table schema.Tabler, on ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p peerTraceDo) RightJoin(table schema.Tabler, on ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.RightJoin(table, on...))
}

func (p peerTraceDo) Group(cols ...field.Expr) *peerTraceDo {
        return p.withDO(p.DO.Group(cols...))
}

func (p peerTraceDo) Having(conds ...gen.Condition) *peerTraceDo {
        return p.withDO(p.DO.Having(conds...))
}

func (p peerTraceDo) Limit(limit int) *peerTraceDo {
        return p.withDO(p.DO.Limit(limit))
}

func (p peerTraceDo) Offset(offset int) *peerTraceDo {
        return p.withDO(p.DO.Offset(offset))
}

func (p peerTraceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *peerTraceDo {
        return p.withDO(p.DO.Scopes(funcs...))
}

func (p peerTraceDo) Unscoped() *peerTraceDo {
        return p.withDO(p.DO.Unscoped())
}

func (p peerTraceDo) Create(values ...*model.PeerTrace) error {
        if len(values) == 0 {
                return nil
        }
        return p.DO.Create(values)
}

func (p peerTraceDo) CreateInBatches(values []*model.PeerTrace, batchSize int) error {
        return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p peerTraceDo) Save(values ...*model.PeerTrace) error {
        if len(values) == 0 {
                return nil
        }
        return p.DO.Save(values)
}

func (p peerTraceDo) First() (*model.PeerTrace, error) {
        if result, err := p.DO.First(); err != nil {
                return nil, err
        } else {
                return result.(*model.PeerTrace), nil
        }
}

func (p peerTraceDo) Take() (*model.PeerTrace, error) {
        if result, err := p.DO.Take(); err != nil {
                return nil, err
        } else {
                return result.(*model.PeerTrace), nil
        }
}

func (p peerTraceDo) Last() (*model.PeerTrace, error) {
        if result, err := p.DO.Last(); err != nil {
                return nil, err
        } else {
                return result.(*model.PeerTrace), nil
        }
}

func (p peerTraceDo) Find() ([]*model.PeerTrace, error) {
        result, err := p.DO.Find()
        return result.([]*model.PeerTrace), err
}

func (p peerTraceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PeerTrace, err error) {
        buf := make([]*model.PeerTrace, 0, batchSize)
        err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
                defer func() { results = append(results, buf...) }()
                return fc(tx, batch)
        })
        return results, err
}

func (p peerTraceDo) FindInBatches(result *[]*model.PeerTrace, batchSize int, fc func(tx gen.Dao, batch int) error) error {
        return p.DO.FindInBatches(result, batchSize, fc)
}

func (p peerTraceDo) Attrs(attrs ...field.AssignExpr) *peerTraceDo {
        return p.withDO(p.DO.Attrs(attrs...))
}

func (p peerTraceDo) Assign(attrs ...field.AssignExpr) *peerTraceDo {
        return p.withDO(p.DO.Assign(attrs...))
}

func (p peerTraceDo) Joins(fields ...field.RelationField) *peerTraceDo {
        for _, _f := range fields {
                p = *p.withDO(p.DO.Joins(_f))
        }
        return &p
}

func (p peerTraceDo) Preload(fields ...field.RelationField) *peerTraceDo {
        for _, _f := range fields {
                p = *p.withDO(p.DO.Preload(_f))
        }
        return &p
}

func (p peerTraceDo) FirstOrInit() (*model.PeerTrace, error) {
        if result, err := p.DO.FirstOrInit(); err != nil {
                return nil, err
        } else {
                return result.(*model.PeerTrace), nil
        }
}

func (p peerTraceDo) FirstOrCreate() (*model.PeerTrace, error) {
        if result, err := p.DO.FirstOrCreate(); err != nil {
                return nil, err
        } else {
                return result.(*model.PeerTrace), nil
        }
}

func (p peerTraceDo) FindByPage(offset int, limit int) (result []*model.PeerTrace, count int64, err error) {
        result, err = p.Offset(offset).Limit(limit).Find()
        if err != nil {
                return
        }

        if size := len(result); 0 < limit && 0 < size && size < limit {
                count = int64(size + offset)
                return
        }

        count, err = p.Offset(-1).Limit(-1).Count()
        return
}

func (p peerTraceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
        count, err = p.Count()
        if err != nil {
                return
        }

        err = p.Offset(offset).Limit(limit).Scan(result)
        return
}

func (p peerTraceDo) Scan(result interface{}) (err error) {
        return p.DO.Scan(result)
}

func (p peerTraceDo) Delete(models ...*model.PeerTrace) (result gen.ResultInfo, err error) {
        return p.DO.Delete(models)
}

func (p *peerTraceDo) withDO(do gen.Dao) *peerTraceDo {
        p.DO = *do.(*gen.DO)
        return p
}
